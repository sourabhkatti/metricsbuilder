import requests
import json
import pprint
import base64
import re
import os
import argparse
import datetime
import calendar


class controller:
    assignee = ""

    # personal apptwo account
    # TEAMSERVER_BASE_URL = "https://apptwo.contrastsecurity.com/Contrast/api/ng/"
    # ORGANIZATION_UUID = "f7ea7169-d4eb-42c4-b32e-5c0ea0ca9733"
    # API_KEY = "KpAoBf7Plj71LFl4ihODRX8CgFh8hyO8"
    # SERVICE_KEY = "ZAXHB4LTKMH25NQ1"
    # TEAMSERVER_USERNAME = "sourabh.katti@contrastsecurity.com"

    #product apptwo account
    TEAMSERVER_BASE_URL = "https://apptwo.contrastsecurity.com/Contrast/api/ng/"
    ORGANIZATION_UUID = "0f767995-4882-4c7c-889f-994d945ff0d5"
    API_KEY = "B6Y14MfSBsmLC6k4GxhIlGk297ZuvG9N"
    SERVICE_KEY = "ZAXHB4LTKMH25NQ1"
    TEAMSERVER_USERNAME = "sourabh.katti@contrastsecurity.com"
    AUTHORIZATION = ""
    header = {}

    FOUND_DATE = "FIRST"
    SORTING = "ALL"

    # Starting date: January 1, 2018
    startingMonth = 1
    startingDay = 1
    startingYear = 2017

    # Ending date: February 10, 2018
    endingMonth = 2
    endingDay = 10
    endingYear = 2018

    endTimeEpoch = 0
    startTimeEpoch = 0

    def __init__(self):
        self.AUTHORIZATION = base64.b64encode((self.TEAMSERVER_USERNAME + ':' + self.SERVICE_KEY).encode('utf-8'))
        self.header = {
            "Authorization": self.AUTHORIZATION,
            "API-Key": self.API_KEY
        }

    # Get date range for the vulnerabilities to pull from teamserver
    def getDateRange(self):
        if self.startingMonth is 0:
            print("Please specify the date range to pull vulnerability information.")
            self.startingMonth = int(input("\tStarting month number (1-12): "))
            while self.startingMonth < 1 or self.startingMonth > 12:
                print("The month should be between 1 and 12!")
                self.startingMonth = int(input("\tStarting month number (1-12): "))

        if self.startingDay is 0:
            self.startingDay = int(input("\tStarting day (1-31): "))
            while self.startingDay < 1 or self.startingDay > 31:
                print("The day should be between 1 and 31!")
                self.startingDay = int(input("\tStarting day (1-31): "))

        if self.endingMonth is 0:
            self.endingMonth = int(input("\tEnding month number (1-12): "))
            while self.endingMonth < 1 or self.endingMonth > 12:
                print("The month should be between 1 and 12!")
                self.endingMonth = int(input("\tEnding month number (1-12): "))

        if self.endingDay is 0:
            self.endingDay = int(input("\tEnding day (1-31): "))
            while self.endingDay < 1 or self.endingDay > 31:
                print("The day should be between 1 and 31!")
                self.endingDay = int(input("\tEnding day (1-31): "))

    def dateTrendManager(self):

        # Get the months and days we'll be looking through
        self.getDateRange()

        yearlyMetrics = {}

        # Loop through all years
        year_index = self.startingYear
        if year_index < self.endingYear:
            while year_index < self.endingYear:
                monthlyMetrics = {}
                for month_index in range(self.startingMonth, 13):
                    month = datetime.datetime(year_index, month_index, 1).strftime("%B")
                    endingDay = calendar.monthrange(year_index, month_index)[1]  # Get the number of days in the month
                    self.startTimeEpoch = int(
                        datetime.datetime(year_index, month_index, 1, 0, 0, 0, 0).timestamp()) * 1000
                    self.endTimeEpoch = int(
                        datetime.datetime(year_index, month_index, endingDay, 23, 59, 59, 99).timestamp()) * 1000
                    print("\n==========> Getting vulns in between %s %d, %d and %s %d, %d" % (
                        month, 1, year_index, month, endingDay, year_index))
                    monthlyMetrics[month] = self.getVulnsByDate()  # Get vulnerabilities for current month
                yearlyMetrics[year_index] = monthlyMetrics
                year_index += 1
            monthlyMetrics = {}
            for month_index in range(1, self.endingMonth):
                month = datetime.datetime(year_index, month_index, 1).strftime("%B")
                endingDay = calendar.monthrange(year_index, month_index)[1]  # Get the number of days in the month
                self.startTimeEpoch = int(
                    datetime.datetime(year_index, month_index, 1, 0, 0, 0, 0).timestamp()) * 1000
                self.endTimeEpoch = int(
                    datetime.datetime(year_index, month_index, endingDay, 23, 59, 59, 99).timestamp()) * 1000
                print("\n==========> Getting vulns in between %s %d, %d and %s %d, %d" % (
                    month, 1, year_index, month, endingDay, year_index))
                monthlyMetrics[month] = self.getVulnsByDate()  # Get vulnerabilities for current month

            month_index += 1
            month = datetime.datetime(year_index, month_index, 1).strftime("%B")
            self.startTimeEpoch = int(
                datetime.datetime(year_index, month_index, 1, 0, 0, 0, 0).timestamp()) * 1000
            self.endTimeEpoch = int(
                datetime.datetime(year_index, month_index, self.endingDay, 23, 59, 59, 99).timestamp()) * 1000
            print("\n==========> Getting vulns in between %s %d, %d and %s %d, %d" % (
                month, 1, year_index, month, self.endingDay, year_index))
            monthlyMetrics[month] = self.getVulnsByDate()  # Get vulnerabilities for current month
            yearlyMetrics[year_index] = monthlyMetrics

        else:
            monthlyMetrics = {}
            for month_index in range(self.startingMonth, self.endingMonth):

                month = datetime.datetime(year_index, month_index, 1).strftime("%B")
                endingDay = calendar.monthrange(year_index, month_index)[1]  # Get the number of days in the month
                self.startTimeEpoch = int(
                    datetime.datetime(year_index, month_index, 1, 0, 0, 0, 0).timestamp()) * 1000
                self.endTimeEpoch = int(
                    datetime.datetime(year_index, month_index, endingDay, 23, 59, 59, 99).timestamp()) * 1000
                print("\n==========> Getting vulns in between %s %d, %d and %s %d, %d" % (
                    month, 1, year_index, month, endingDay, year_index))
                monthlyMetrics[month] = self.getVulnsByDate()  # Get vulnerabilities for current month

            month_index += 1
            month = datetime.datetime(year_index, month_index, 1).strftime("%B")
            self.startTimeEpoch = int(
                datetime.datetime(year_index, month_index, 1, 0, 0, 0, 0).timestamp()) * 1000
            self.endTimeEpoch = int(
                datetime.datetime(year_index, month_index, self.endingDay, 23, 59, 59, 99).timestamp()) * 1000
            print("\n==========> Getting vulns in between %s %d, %d and %s %d, %d" % (
                month, 1, year_index, month, self.endingDay, year_index))
            monthlyMetrics[month] = self.getVulnsByDate()  # Get vulnerabilities for current month
            yearlyMetrics[year_index] = monthlyMetrics

        cumulative_yearly_metrics = self.getCumulativeCounts(yearlyMetrics)
        print(cumulative_yearly_metrics)

    def getCumulativeCounts(self, yearlymetrics):
        cumulative_total_counts = 0
        cumulative_serious_total_counts = 0
        for year, monthlymetrics in yearlymetrics.items():
                for month, metrics in monthlymetrics.items():
                    try:
                        cumulative_total_counts += metrics['total_traces']
                        cumulative_serious_total_counts += metrics['serious_traces']

                        metrics['cumulative_total_traces'] = cumulative_total_counts
                        metrics['cumulative_serious_traces'] = cumulative_serious_total_counts

                        print(year, month, metrics['total_traces'], cumulative_total_counts, metrics['serious_traces'], cumulative_serious_total_counts)
                    except:
                        print(year, month, "no new vulns")
        return yearlymetrics

    def getVulnsByDate(self):
        print(
            "Fetch Vulnerabilities, sorting by " + self.SORTING + " and " + self.FOUND_DATE + " found in the date range...")

        endpoint = self.TEAMSERVER_BASE_URL + self.ORGANIZATION_UUID + "/orgtraces" \
                                                                       "/filter/?endDate=" + str(
            self.endTimeEpoch) + "&expand=application,servers,violations,bugtracker," \
                                 "skip_links&quickFilter=" + self.SORTING + "&limit=100000&sort=-lastTimeSeen&startDate=" + str(
            self.startTimeEpoch) + \
                   "&timestampFilter=" + self.FOUND_DATE

        print("\tSending request to teamserver", end="")

        try:
            # Get all vulns which need an issue opened for them
            r = requests.get(url=endpoint, headers=self.header)
            vulns = json.loads(r.text)
            print(".... Done!")
            return self.getVulnMetrics(vulns['traces'])
        except Exception as e:
            print("ERROR: Unable to connect to teamserver. Please check your authentication details.")
            print(e)
            return -1

    def getVulnMetrics(self, vulns):
        print("\nParsing Vulnerabilities...")

        traceNum = vulns.__len__()

        # total_traces = Total number of traces found in this time span
        # serious_traces = Total number of CRITICAL or HIGH vulns
        # serious_category_counts = Total number of serious categories and the number of vulns found in each one
        # changed_status = Number of vulns with a status other than Reported
        # remediated_status = Number of vulns with a status of Remediated, Not a Problem or Fixed
        metrics = {}

        try:
            if traceNum > 0:
                print("\tTotal number of traces: %d" % traceNum)
                metrics['total_traces'] = traceNum

                seriousVulnCounter = 0
                seriousCategoryCounter = {}

                remediatedStatusCount = 0
                statusCount = 0
                for vuln in vulns:

                    # Check severity for serious vulns and increment counter for that severity
                    if vuln['default_severity'] in ("CRITICAL", "HIGH"):
                        seriousVulnCounter += 1
                        if vuln['rule_name'] in seriousCategoryCounter.keys():
                            seriousCategoryCounter[vuln['rule_name']] += 1
                        else:
                            seriousCategoryCounter[vuln['rule_name']] = 1

                    if vuln['status'] in ("Remediated", "Fixed", "Not a Problem", "Suspicious", "Confirmed"):
                        if vuln['status'] in ("Remediated", "Fixed", "Not a Problem"):
                            remediatedStatusCount += 1
                        statusCount += 1

                print("\n\tSerious Vulnerabilities Metrics")
                print("\t\t- Number of serious vulnerabilities: %d" % seriousVulnCounter)
                metrics['serious_traces'] = seriousVulnCounter

                category_counts = {}
                for category, count in seriousCategoryCounter.items():
                    print("\t\t\t* %s: %d" % (category, count))
                    category_counts[category] = count
                metrics['serious_category_counts'] = category_counts

                print("\n\tVulnerability Status")
                print("\t\t- Number of vulns in a status besides Reported:", statusCount)
                metrics['changed_status'] = statusCount

                print("\t\t- Number of vulnerabilities marked Remediated, Not a Problem or Fixed:",
                      remediatedStatusCount)
                metrics['remediated_status'] = remediatedStatusCount

                return metrics

            else:
                print("\tThere were no traces found during the specified date range")
                return -1
        except:
            print("Could not parse retrieved vulnerabilities")
            return -1

    def getApplications(self):
        print("\nApplication Metrics")
        endpoint = self.TEAMSERVER_BASE_URL + self.ORGANIZATION_UUID + "/applications/filter?expand=scores,license," \
                                                                       "trace_breakdown,compliance_policy," \
                                                                       "production_protected," \
                                                                       "skip_links&filterText=&includeArchived=false" \
                                                                       "&includeMerged=true&limit=100000&quickFilter" \
                                                                       "=ALL&sort=appName"
        try:
            r = requests.get(url=endpoint, headers=self.header)
            applications = json.loads(r.text)
            print("\t- Number of applications:", applications['applications'].__len__())
        except:
            print("ERROR: Unable to retrieve applications")


controller = controller()
controller.dateTrendManager()
controller.getApplications()
